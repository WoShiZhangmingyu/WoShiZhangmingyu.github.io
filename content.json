{"posts":[{"title":"BIO&#x2F;NIO&#x2F;AIO的异同","text":"在计算机系统中，I/O（输入/输出）操作是程序与外部世界（如文件、网络等）交互的重要手段。现代操作系统提供了三种不同的I/O模型：BIO（阻塞I/O）、NIO（非阻塞I/O）和AIO（异步I/O），它们在设计思想、工作机制和适用场景上有着显著差异。本文将深入剖析这三种I/O模型的核心概念、实现原理以及各自的优缺点，以帮助读者理解不同I/O模型在系统设计中的应用。 BIO (Blocking I/O，阻塞I/O)概念与原理BIO是传统的I/O编程模型，其特点是简单直观但效率较低。在BIO模型中，当一个线程发起I/O操作后，该线程会被阻塞直到I/O操作完成。这种模型对应于POSIX标准中的最基本的I/O操作方式。 工作机制BIO的工作机制基于线程阻塞原理。当应用程序调用read()等系统调用时，线程会从用户态切换到内核态。如果请求的数据尚未准备好，内核会将线程置为睡眠状态并移出运行队列，释放CPU资源给其他线程使用。 当数据准备就绪（如网络数据包到达）时，设备会触发中断，通知CPU数据已到达。内核将数据放入缓冲区，并将等待的线程重新唤醒，加入运行队列。线程获得CPU时间片后，将数据从内核缓冲区复制到用户空间，然后返回继续执行。 一次完整的BIO操作通常涉及两次用户态与内核态的切换： 第一次切换：应用程序调用read()等系统调用时，从用户态切换到内核态 第二次切换：系统调用完成后，从内核态切换回用户态 如果数据未就绪导致阻塞，在线程被唤醒后继续执行系统调用时，实际上不会产生额外的用户态与内核态切换，因为线程仍然在内核态执行。但这个过程会涉及上下文切换：当线程阻塞时让出CPU，当数据就绪后重新获得CPU执行权。这种上下文切换虽然不是用户态与内核态的切换，但同样会带来性能开销。 在服务器应用中，BIO通常采用”一个连接一个线程”的模式。每当接收到新的客户端连接，服务器就会创建或分配一个线程专门处理该连接的所有I/O操作。这导致高并发场景下线程数量剧增，系统资源消耗严重。 底层实现BIO底层依赖操作系统的阻塞式系统调用。以网络读取为例，实现过程如下： 应用程序通过系统调用请求读取数据，控制权转移给内核 内核检查是否有数据可读，若无，将线程加入等待队列并挂起 网络数据到达时，网卡产生中断，内核处理数据并放入socket缓冲区 内核唤醒等待的线程，将其标记为可运行状态 线程恢复执行，将数据从内核缓冲区复制到用户空间 系统调用返回，线程继续在用户态执行 这种实现方式在并发连接较少时表现良好，但随着连接数增加，线程资源消耗（内存、上下文切换开销等）会迅速增长，导致系统性能下降。这就是所谓的”C10K问题”——传统BIO模型难以处理万级并发连接。 代码示例12345678910111213141516171819// BIO服务器示例ServerSocket serverSocket = new ServerSocket(8080);while (true) { // 阻塞直到有客户端连接 Socket clientSocket = serverSocket.accept(); // 为每个客户端创建一个新线程 new Thread(() -&gt; { try (InputStream in = clientSocket.getInputStream()) { // 读取数据（阻塞操作） byte[] buffer = new byte[1024]; int len; while ((len = in.read(buffer)) != -1) { System.out.println(new String(buffer, 0, len)); } } catch (IOException e) { e.printStackTrace(); } }).start();} 优缺点优点： 设计简单，编程模型直观 代码结构清晰，易于理解 适合连接数较少且固定的应用 缺点： 性能低下，线程阻塞导致资源浪费 可伸缩性差，线程数量增加会导致系统负担加重 高并发场景下，频繁的线程创建和销毁会带来大量开销 NIO (Non-blocking I/O，非阻塞I/O)概念与原理NIO是一种非阻塞I/O模型，它允许线程在等待I/O操作完成的同时执行其他任务。NIO通过选择器（Selector）实现多路复用，使一个线程能够管理多个通道（Channel）的I/O操作，从而提高资源利用率。 工作机制NIO的工作机制基于I/O多路复用和事件驱动。应用程序首先将通道注册到选择器上，指定关注的事件类型（如读、写、连接等）。然后通过选择器查询哪些通道已经准备好执行I/O操作。 在实际运行时，应用线程调用selector.select()方法等待事件发生。此方法可能会短暂阻塞，直到至少有一个通道准备就绪，或者超时。与BIO不同，这种阻塞是主动控制的，且一次阻塞可以等待多个I/O事件。 当有通道就绪时，select()方法返回，应用程序获取就绪通道的集合，然后遍历处理这些通道上的I/O事件。处理完成后，线程再次调用select()等待下一批事件。这种模式下，一个线程能够处理多个连接，大大提高了系统的并发处理能力。 用户态和内核态的切换方面，NIO在执行select()操作时会从用户态切换到内核态，然后返回时再切换回用户态。与BIO不同的是，一次select()调用可以处理多个通道的事件，减少了切换次数。当通道就绪后，读写操作也各需要一次用户态/内核态切换，但由于只处理已就绪的通道，不会发生阻塞等待。 底层实现NIO底层依赖操作系统的I/O多路复用机制，如Linux的epoll、BSD的kqueue和Windows的IOCP等。以epoll为例，其实现过程如下： 应用程序创建epoll实例，相当于Java中的Selector对象 将需要监听的文件描述符（套接字）注册到epoll实例，指定关注的事件类型 调用epoll_wait()等待事件发生，这一步可能会短暂阻塞 当有事件发生时，内核将就绪的文件描述符和对应事件放入就绪列表 epoll_wait()返回就绪事件的数量，应用程序遍历就绪列表处理I/O事件 处理完成后，再次调用epoll_wait()等待新的事件 这种机制避免了BIO中”一个连接一个线程”的资源消耗问题，实现了用较少的线程处理大量连接的目标。尤其是在连接数量多但活跃度不高的场景（如聊天服务器），NIO的优势更为明显。 需要注意的是，虽然NIO避免了不必要的阻塞，但应用程序需要自行处理数据的读取和缓冲，增加了编程复杂度。同时，由于采用轮询机制，若没有I/O事件发生，select()调用也会消耗CPU资源。 代码示例1234567891011121314151617181920212223242526272829303132333435// NIO服务器示例ServerSocketChannel serverChannel = ServerSocketChannel.open();serverChannel.bind(new InetSocketAddress(8080));serverChannel.configureBlocking(false);Selector selector = Selector.open();serverChannel.register(selector, SelectionKey.OP_ACCEPT);while (true) { // 非阻塞或阻塞较短时间 selector.select(); Iterator&lt;SelectionKey&gt; keyIterator = selector.selectedKeys().iterator(); while (keyIterator.hasNext()) { SelectionKey key = keyIterator.next(); keyIterator.remove(); if (key.isAcceptable()) { // 处理新连接 ServerSocketChannel server = (ServerSocketChannel) key.channel(); SocketChannel client = server.accept(); client.configureBlocking(false); client.register(selector, SelectionKey.OP_READ); } else if (key.isReadable()) { // 处理读事件 SocketChannel client = (SocketChannel) key.channel(); ByteBuffer buffer = ByteBuffer.allocate(1024); int bytesRead = client.read(buffer); if (bytesRead &gt; 0) { buffer.flip(); System.out.println(new String(buffer.array(), 0, buffer.limit())); } } }} 优缺点优点： 单线程可以处理多个连接，提高资源利用率 减少线程上下文切换的开销，提升系统性能 适合高并发、大量连接但流量较小的场景 缺点： 编程复杂度高，学习曲线陡峭 需要开发者自行处理数据的读写边界 可能导致CPU负载较高，因为需要不断轮询就绪的通道 AIO (Asynchronous I/O，异步I/O)概念与原理AIO代表异步I/O，是最接近理想I/O模型的一种实现。在AIO模式下，应用程序发起I/O操作后立即返回，继续执行其他任务，当I/O操作完全完成（包括数据准备和数据从内核复制到用户空间）后，系统会通知应用程序。这是真正的非阻塞异步I/O模型。 工作机制AIO的工作机制完全基于事件和回调。应用程序发起I/O请求时，会同时注册一个回调函数。之后，无论I/O是否完成，应用程序都可以执行其他任务，不需要等待或轮询。 当I/O操作完全完成后，操作系统会触发注册的回调函数，通知应用程序处理结果。这整个过程不需要应用程序主动查询I/O状态，实现了I/O操作与程序执行的完全分离。 从用户态和内核态切换的角度看，AIO在初始提交I/O请求时会有一次从用户态到内核态的切换。之后应用程序可以继续在用户态执行其他代码。当I/O操作完成时，内核会通过回调机制通知应用程序，此时会再发生一次从内核态到用户态的切换。与BIO和NIO相比，AIO的一个重要优势是完成数据从内核缓冲区到用户缓冲区的复制不需要应用程序参与。 底层实现AIO的底层实现依赖于操作系统提供的异步I/O支持。在Windows系统上，AIO通过IOCP（I/O完成端口）实现；在Linux系统上，早期通过AIO系统调用实现，但功能有限，近期的高版本内核则提供了更强大的io_uring机制。 以Windows的IOCP为例，其实现过程如下： 应用程序创建I/O完成端口，并将套接字与之关联 应用程序发起异步I/O请求，同时提供完成回调函数或例程 应用程序继续执行其他任务，不需要等待I/O完成 当I/O操作完成时，系统将完成事件放入完成端口队列 应用程序中的工作线程从完成端口获取事件并处理 处理完成后，工作线程可以继续获取下一个完成事件 这种机制完全消除了应用程序对I/O状态的轮询，实现了更高效的资源利用。特别是在大文件传输、数据库访问等I/O密集型应用中，AIO能够显著提高系统吞吐量。 需要注意的是，由于AIO依赖操作系统的支持，在不同平台上的实现质量和性能可能有所差异。特别是在Linux系统上，传统的AIO支持较弱，只有近期的内核版本才提供了更完善的异步I/O支持。 代码示例12345678910111213141516171819202122232425262728293031323334// AIO服务器示例AsynchronousServerSocketChannel serverChannel = AsynchronousServerSocketChannel.open();serverChannel.bind(new InetSocketAddress(8080));serverChannel.accept(null, new CompletionHandler&lt;AsynchronousSocketChannel, Void&gt;() { @Override public void completed(AsynchronousSocketChannel client, Void attachment) { // 继续接受下一个连接 serverChannel.accept(null, this); // 处理当前连接 ByteBuffer buffer = ByteBuffer.allocate(1024); client.read(buffer, buffer, new CompletionHandler&lt;Integer, ByteBuffer&gt;() { @Override public void completed(Integer bytesRead, ByteBuffer buffer) { if (bytesRead &gt; 0) { buffer.flip(); System.out.println(new String(buffer.array(), 0, buffer.limit())); // 可以继续读取或执行其他操作 } } @Override public void failed(Throwable exc, ByteBuffer attachment) { exc.printStackTrace(); } }); } @Override public void failed(Throwable exc, Void attachment) { exc.printStackTrace(); }}); 优缺点优点： 真正的异步操作，I/O效率最高 应用程序无需轮询，资源消耗更低 适合I/O密集型应用，特别是读写操作耗时较长的场景 缺点： 编程模型更复杂，回调函数可能导致代码可读性下降 依赖操作系统的异步I/O支持，在某些平台上实现不够完善 调试和错误处理较为困难 三种I/O模型的对比阻塞特性对比 BIO：完全阻塞，一个线程处理一个连接 NIO：非阻塞，但需要应用程序主动轮询I/O状态 AIO：完全非阻塞，异步通知I/O完成事件 编程复杂度 BIO：最简单，适合初学者 NIO：较复杂，需要理解Buffer、Channel、Selector等概念 AIO：最复杂，需要掌握回调和异步编程模式 性能对比 BIO：性能最低，不适合高并发场景 NIO：性能中等，适合连接数多但处理时间短的场景 AIO：理论上性能最高，适合I/O密集型应用 适用场景 BIO：连接数较少、业务处理简单的应用 NIO：高并发、需要管理大量连接的服务器应用 AIO：文件操作、数据库访问等I/O密集型应用 操作系统层面的I/O模型从操作系统角度看，可以将I/O模型分为五类： 阻塞I/O（Blocking I/O）：进程发起I/O系统调用后阻塞，直到I/O操作完成 非阻塞I/O（Non-blocking I/O）：进程发起I/O系统调用后立即返回，需要轮询检查I/O是否完成 I/O多路复用（I/O Multiplexing）：通过select/poll/epoll等机制监控多个文件描述符 信号驱动I/O（Signal-driven I/O）：进程发起I/O请求后继续执行，I/O就绪时接收信号通知 异步I/O（Asynchronous I/O）：进程发起I/O请求后继续执行，I/O操作完全完成后接收通知 其中，Java的BIO对应阻塞I/O模型，NIO对应I/O多路复用模型，而AIO对应异步I/O模型。 I/O多路复用技术对比Linux系统中的select、poll和epoll都属于I/O多路复用模型，它们的目标都是监控多个文件描述符，但实现机制和性能特点有所不同： select： 最早的I/O多路复用实现 监控的文件描述符数量有限制（通常为1024） 每次调用需要将整个文件描述符集合从用户态复制到内核态 返回时需要遍历整个集合以找出就绪的描述符 时间复杂度为O(n)，随监控的描述符数量增加性能下降明显 poll： select的改进版 没有文件描述符数量的固定限制 同样需要在每次调用时复制文件描述符集合 也需要遍历整个集合查找就绪的描述符 时间复杂度仍为O(n)，大量描述符时性能同样会下降 epoll： Linux特有的高性能I/O多路复用机制 使用事件通知机制，只返回就绪的文件描述符 描述符只在添加到监控集合时从用户态复制到内核态一次 没有最大文件描述符数量的限制（除系统资源外） 时间复杂度接近O(1)，性能基本不随监控的描述符数量增加而下降 在高并发场景下性能远优于select和poll 这三种机制都属于I/O多路复用模型，在Java的NIO实现中都可能被使用，具体使用哪种取决于操作系统平台。Java NIO会根据不同平台选择最优的多路复用实现，在Linux上优先使用epoll，在BSD系统上使用kqueue，在Windows上使用完成端口等。 实际应用举例BIO应用场景 简单的客户端应用 连接数有限的小型服务器 学习和教学环境 NIO应用场景 Netty网络应用框架 Tomcat 7+版本的连接器 Redis的Java客户端 AIO应用场景 大型文件处理系统 高性能数据库连接池 实时消息处理系统 总结理解BIO、NIO和AIO的区别对于设计高性能的网络应用至关重要。BIO提供了简单直观的编程模型但性能有限；NIO通过非阻塞I/O和多路复用提高了资源利用率；AIO则通过真正的异步操作进一步优化了I/O效率。根据应用场景的特点和需求，选择合适的I/O模型能够有效提升系统性能和可伸缩性。 在实际开发中，我们常常会结合使用这些I/O模型，或者通过成熟的框架如Netty间接使用它们，以便在保持代码简洁的同时获得高性能。","link":"/2025/06/04/BIO-NIO-AIO%E7%9A%84%E5%BC%82%E5%90%8C/"},{"title":"MIT6.824(6.5840)lab2A个人实现记录","text":"终于来到了最难的lab3，我做的是2024 版，新增了一个KVServer为lab2，原来的raft就变成lab3了首先阅读论文：Raft是一种基于日志复制的一致性算法，比paxos更加简单易学且易于实现Raft技术特点： 将问题分解为独立的易于理解和解决的子问题 通过减少需要考虑的状态来简化状态空间。这使得系统更加一致并尽可能消除不确定的状态 具体的论文细节就不赘述了，网上有很多写的很好的总结，本文主要记录我的个人实现过程和细节 lab3A是实现leader的选举 首先想着把论文中Figure2中的state写进去，这一步简单地按照论文中的Figure2中写就行了 用自带的debug函数Dprintf函数探了探路，启动go test -run 3A后发现创建了3个raft。这下目标明确了：为Raft添加状态，leader、follower、candidate。make函数创建raft时当然是follower状态啦 这个时候就没什么思路了，到处看了看发现getstate这个函数比较好写，就写了 论文中提到了选取Leader时出现多个Leader的情况，设置一个随机的选取时间避免选取出多个Leader的情况 random 重新看了看论文的实现思路并参考了大量文章，决定使用Timer定时器和ticker循环定时器分别作为选举和心跳的定时器 实现ticker()，框架中给了for rf.killed() == false{}，使用select case 调用心跳或者选举 重点实现函数electLeader,electTime到期时调用，Leader变成candidate，currentTerm++，给自己投票（voteFor=me）然后遍历rf.peers请求所有peer（类型为Candidate）为其投票，其中记录投票的票数。如果过半则当选Leader，当选后立刻给其他peer广播心跳heartBeat（）注意：若其他peer的Term大于currentTerm则本rf退化为Follwer，currentTerm也更新为该Term 再实现心跳函数heartBeat，心跳函数用time.ticker调用，循环定时器完美满足此应用场景，只需要在心跳函数中增加一个是否为Leader的判断就行 细节多多注意锁的使用，本人就是在锁的使用上犯了糊涂，妄图使用一把大锁来包平安，但是在并发的条件下似乎不太行得通，必须减少锁的粒度（也就是被锁住的操作）另外还要注意锁的lock与unlock的搭配，上锁后必须解锁！！ debug 多利用raft/util.go中的DPrintf函数进行分析 在实现的过程中出现了warning: term changed even though there were no failures的问题，经过大量查阅资料和DPrintf来检查，先后发现了三个错误，一是重置rf的electTime的时机，二是原来心跳的定时器使用的是Timer单次定时器而不是Ticker循环定时器，三是在调用heartBeat时对它加上了锁，在heartBeat内部也加了锁，导致卡在heartBeat函数内部 有四个重置electTime的时机 给别的peer投票 收到了符合要求的heartbeat 自己发起了选举 自己是Leader，给别的Follower发送heartBeat。遍历到自己时，不需要给自己发送heartbeat，但要记得重置electTime 改用循环定时器Ticker来触发正常的心跳以便维持一个未出错的Leader任期（Term） 调用heartBeat时不需要加锁","link":"/2024/04/29/MIT6-824-6-5840-lab2A%E4%B8%AA%E4%BA%BA%E5%AE%9E%E7%8E%B0%E8%AE%B0%E5%BD%95/"},{"title":"“JAVA反射机制详解”","text":"什么是反射？反射是与正射相对应的，正射就是在使用某个类之前就已经知道了这个类的类型等等，可以直接使用new关键字调用构造方法进行初始化，之后就可以正常使用这个类的的对象了Java 反射机制是在运行状态中，对于任意一个类，都能够知道这个类中的所有属性和方法，对于任意一个对象，都能够调用它的任意一个方法和属性;这种动态获取的信息以及动态调用对象的方法的功能称为Java 语言的反射机制。 反射的特点 运行时类信息访问：反射允许程序在运行时获取类的完结构信息，包括类名、包名、父类、实现的接口、构造函数、方法和字段等等 动态对象创建:可以使用反射API动态地创建对象实例，即使在编译时不知道具体的类名。这是通过Class类的newInstance()方法或Constructor对象的newnstance()方法实现的。 动态方法调用:可以在运行时动态地调用对象的方法，包括私有方法。这通过Method类的invoke()方法实现，允许你传入对象实例和参数值来执行方法。4.访问和修改字段值:反射还允许程序在运行时访问和修改对象的字段值，即使是私有的。这是通过Field类的qet()和set()方法完成的 反射的缺点破坏封装:由于反射允许访问私有字段和私有方法，所以可能会破坏封装而导致安全问题性能开销:由于反射涉及到动态解析，因此无法执行Java 虚拟机优化，再加上反射的写法的确要复杂得多，所以性能要比“正射”差很多，在一些性能敏感的程序中应该避免使用反射。 反射的应用场景 通用框架中加载配置文件：类似spring、springboot等，为了保持通用性，通过不同的配置文件来加载不同的对象，比如数据库驱动等等 动态代理：在面向切面编程中，需要拦截特定的方法，就会选择动态代理的方式，动态代理的底层实现就是利用了反射 注解：注解本身不会直接影响程序的执行，但可以通过反射机制在运行时获取和处理这些注解 反射的基本使用在 Java 中，Class 对象是一种特殊的对象，它代表了程序中的类和接口。Java 中的每个类型（包括类、接口、数组以及基础类型）在 JVM 中都有一个唯一的 Class 对象与之对应。这个 Class 对象被创建的时机是在 JVM 加载类时，由 JVM 自动完成。Class 对象中包含了与类相关的很多信息，如类的名称、类的父类、类实现的接口、类的构造方法、类的方法、类的字段等等。这些信息通常被称为元数据（metadata）。 获取类的Class对象共有三种方法： 通过类的全名获取Class对象1Class clazz = Class.forName(&quot;com.xxx&quot;); 通过 Class 对象获取构造方法 Constructor 对象1Constructor constructor = clazz.getConstructor(); 通过 Constructor 对象初始化反射类对象1Object object = constructor.newInstance(); 获取要调用的方法的 Method 对象12Method setNameMethod = clazz.getMethod(&quot;setName&quot;, String.class);Method getNameMethod = clazz.getMethod(&quot;getName&quot;); 通过 invoke() 方法执行12setNameMethod.invoke(object, &quot;zhangsan&quot;);getNameMethod.invoke(object) 反射底层机制使用反射，必须要获得反射类的Class对象，每一个类只有一个Class对象，无论这个类生成了多少个对象。这个Class对象是由JAVA虚拟机生成的，由它来获取这个类的所有结构信息也就是说，java.lang.Class 是所有反射 API 的入口但是方法的反射调用都是通过Method对象的invoke()方法完成的 1234567891011121314151617181920public Object invoke(Object obj, Object... args) throws IllegalAccessException, IllegalArgumentException, InvocationTargetException { // 如果方法不允许被覆盖，进行权限检查 if (!override) { if (!Reflection.quickCheckMemberAccess(clazz, modifiers)) { Class&lt;?&gt; caller = Reflection.getCallerClass(); // 检查调用者是否具有访问权限 checkAccess(caller, clazz, obj, modifiers); } } // 获取方法访问器（从 volatile 变量中读取） MethodAccessor ma = methodAccessor; if (ma == null) { // 如果访问器为空，尝试获取方法访问器 ma = acquireMethodAccessor(); } // 使用方法访问器调用方法，并返回结果 return ma.invoke(obj, args);} invoke() 方法实际上是委派给 MethodAccessor 接口来完成的 MethodAccessor 接口有三个实现类，其中的 MethodAccessorImpl 是一个抽象类，另外两个具体的实现类 NativeMethodAccessorImpl 和 DelegatingMethodAccessorImpl 继承了这个抽象类。NativeMethodAccessorImpl：通过本地方法来实现反射调用；DelegatingMethodAccessorImpl：通过委派模式来实现反射调用； invoke() 方法在执行的时候，会先调用 DelegatingMethodAccessorImpl，然后调用 NativeMethodAccessorImpl，最后再调用实际的方法 为什么不直接调用本地实现呢？之所以采用委派实现，是为了能够在本地实现和动态实现之间切换。动态实现是另外一种反射调用机制，它是通过生成字节码的形式来实现的。如果反射调用的次数比较多，动态实现的效率就会更高，因为本地实现需要经过 Java 到 C/C++ 再到 Java 之间的切换过程，而动态实现不需要；但如果反射调用的次数比较少，反而本地实现更快一些。而这个临界点默认是15次，可以通过 -Dsun.reflect.inflationThreshold 参数类调整 反射常用的APIClass.forName()，参数为反射类的完全限定名。 类名 + .class，只适合在编译前就知道操作的 Class。 获取构造器、字段、方法等 getConstructor()：返回反射类的特定 public 构造方法，可以传递参数，参数为构造方法参数对应 Class 对象；缺省的时候返回默认构造方法。getDeclaredConstructor()：返回反射类的特定构造方法，不限定于 public 的。getConstructors()：返回类的所有 public 构造方法。getDeclaredConstructors()：返回类的所有构造方法，不限定于 public 的。获取字段和方法都是类似，换成Field或者Method就行 注意，如果反射访问私有字段和（构造）方法的话，需要使用 Constructor/Field/Method.setAccessible(true) 来绕开 Java 语言的访问限制 注：参考javabetter和xiaolincoding，侵删","link":"/2024/10/14/%E2%80%9CJAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3%E2%80%9D/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2025/06/02/hello-world/"},{"title":"“Redis常见面试题（持续更新）”","text":"缓存三兄弟缓存穿透查询一个不存在的数据，redis查询不到，再查询mysql也查询不到，也不会直接写入缓存，导致每次请求都查询数据库有人恶意通过发送大量不存在的请求，导致数据库宕机 解决方案一：缓存redis缓存空数据，查询返回的数据为空，仍然把这个空结果进行缓存优点：简单缺点：消耗内存，可能会发生不一致的问题 解决方案二：布隆过滤器布隆过滤器，在查询redis前，先查询布隆过滤器，检索一个元素是否在一个集合中布隆过滤器原理：存储数据：通过对数据进行若干个哈希函数计算得到哈希值，将bitmap对应位置的值置为一查询数据：使用相同的哈希函数获取哈希值，判断对应位置是否都为一，如果不全为一说明不存在注意：“不存在一定不存在，存在不一定存在”误判率：作为一个参数可以被设置，数组越小误判率越大，数组越大误判率越小，但响应的内存占用越大优点：占用内存少，没有多余key缺点：实现复杂，存在误判 缓存击穿给某一个热点key设置了过期时间，当key过期时，恰好这时这个时间点对这个key有大量的并发请求，可能导致压垮数据库 解决方案一：互斥锁互斥锁，当线程查询redis失败后，不立刻去请求数据库，而是使用如Redis的setnx去设置一个互斥锁，当获取锁成功时才进行查询，写入缓存完成后在释放锁优点：可以保证redis和数据库的强一致性缺点，性能差 解决方案二：自动续期缓存击穿是由于热点key过期导致的，所以可以使用一个job给热点key自动更新缓冲，重新设置过期时间为30分钟 解决方案三：永不过期对于很多热门key，其实是可以不用设置过期时间，让其永久有效的。比如参与秒杀活动的热门商品，由于这类商品id并不多，在缓存中我们可以不设置过期时间。在秒杀活动开始前，我们先用一个程序提前从数据库中查询出商品的数据，然后同步到缓存中，提前做预热等压力过去之后，再手动删除这些无用的缓存 缓存雪崩同时有多个key失效或者redis服务宕机，导致大量请求到达数据库，给数据库带来巨大压力 解决方案一：过期时间加随机数为了解决缓存雪崩问题，我们首先要尽量避免缓存同时失效的情况发生，可以在过期时间上加上一个随机数，这样即使在高并发的情况下，多个请求同时设置过期时间，由于有随机数的存在，也不会出现太多相同的过期key。 解决方案二：高可用针对缓存服务器down机的情况，在前期做系统设计时，可以做一些高可用架构。比如：如果使用了redis，可以使用哨兵模式，或者集群模式，避免出现单节点故障导致整个redis服务不可用的情况。使用哨兵模式之后，当某个master服务下线时，自动将该master下的某个slave服务升级为master服务，替代已下线的master服务继续处理请求。","link":"/2024/10/14/%E2%80%9CRedis%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89%E2%80%9D/"},{"title":"初步了解Kubernetes（k8s）及其工作原理","text":"k8s是介于应用服务和服务器之间的中间层，通过策略，协调和管理多个应用服务，只需要一个yaml文件配置，定义应用的部署顺序等信息，就能自动部署应用到各个服务器上，还可以实现服务器的自动重启，自动扩缩容 k8s架构原理为了实现以上功能，k8s将服务器划分为两部分，控制平面（control plane）、工作结点（Node） 字面意思，控制平面控制工作结点，工作节点负责运行各个应用服务 控制平面内部组件 API Server通过k8s提供的API接口，就可以快捷地操作服务器资源 Scheduler调度器，负责找到cpu和内存资源充足的服务器，在该服务器上部署应用 Controller Mannager控制管理器，负责找到服务器后控制和关闭服务 存储层保存上述功能产生的数据，目前使用的是etcd Node内部组件使用了k8s之后，只需要将服务代码打包成Container Image（容器镜像），就能一行命令将它部署。而容器镜像简单理解就是应用代码和系统环境的压缩包。为了下载和部署容器镜像，Node中有一个Container runtime组件每一个应用服务都可以认为是一个Container（容器），服务器通常情况下还有日志收集器Container或者监控收集器Container，多个Container共同组成一个Pod，Pod运行在Node上k8s可以将Pod从一个Node调度到另一个Node，还可以以Pod为单位去重启和动态扩缩容。所以，**Pod是k8s中最小的调度单位 kubelet主要通过从Controller Manager接受命令来管理和监控PodKube Proxy负责Node的网络通信功能，有了它，外部请求才能被转发到Pod内 Cluster控制平面和Node共同组成了一个Cluster，也就是集群，同时，为了将集群内部的服务暴露给外部用户使用，我们一般还会部署一个入口控制器，比如 Ingress 控制器（比如 Nginx），它可以提供一个入口让外部用户访问集群内部服务 kubectlkubectl是一个命令行工具，只要我们执行命令，kubectl内部就会调用k8s的API，而不需要我们自己写代码去调用k8s提供的API k8s部署服务的过程 首先编写YAML文件，在里面定义Pod里用到了哪些镜像容器，占用了多少内存和CPU等信息 再使用kubectl命令行工具执行kubectl apply -f xx.yaml，kubectl就会读取和解析YAML文件，将解析后的对象通过API请求发送给Kubenetes控制平面内的API Server。 API Server会根据要求，去世Scheduler通过etcd提供的数据寻找合适的Node。 Controller Manager会通过API Server控制Node创建服务，Node内部的kubelet在收到命令后会开始基于Container runtime 组件去拉去镜像创建容器，最终完成Pod的创建 如何调用服务？外部请求会先到达k8s集群的ingress控制器，然后请求会被转发到k8s内部的某个Node的Kube Proxy上，再找到对应的Pod，然后才是转发到内部容器中，处理结果原路返回。到此完成一次服务调用 参考：小白debug","link":"/2024/05/16/%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3Kubernetes%EF%BC%88k8s%EF%BC%89%E5%8F%8A%E5%85%B6%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"},{"title":"[操作系统]常见面试题--无序版","text":"操作系统64位与32位的区别内存寻址能力：64位操作系统通常最大可支持16EB的物理内存，32位由于地址空间的限制，最多只有4GB的物理内存运算性能：64位CPU有更宽的通用寄存器和更大的指令集，一次可以处理更多数据 进程和线程的区别 进程是系统资源分配和调度的最小单元，线程是CPU调度和分配的最小单位 一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程 进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率 资源分配给进程，同一进程的所有线程共享该进程的所有资源 进程的创建、销毁、切换的开销大于线程 线程不能独立执行，必须依存在进程中 线程快在哪？ 线程创建时有些资源不需要自己管理，直接从进程取用，线程只需要管理寄存器和栈的声明周期 同一进程内多个线程共享数据，所以进程数据传输可以用零拷贝技术，不需要经过内核 进程使用一个虚拟内存跟页表，然后多个线程共用这些虚拟内存，如果同进程内两个线程进行上下文切换比进程快很多 线程分为用户态线程和内核态线程，二者有什么区别？用户态线程工作在用户空间，内核态线程工作在内核空间。用户态线程调度完全由进程负责，通常就是由进程的主线程负责。相当于进程主线程的延展，使用的是操作系统分配给进程主线程的时间片段。内核线程由内核维护，由操作系统调度。 用户态线程无法跨核心，一个进程的多个用户态线程不能并发，阻塞一个用户态线程会导致进程的主线程阻塞，直接交出执行权限。这些都是用户态线程的劣势。内核线程可以独立执行，操作系统会分配时间片段。因此内核态线程更完整，也称作轻量级进程。内核态线程创建成本高，切换成本高，创建太多还会给调度算法增加压力，因此不会太多。 实际操作中，往往结合两者优势，将用户态线程附着在内核态线程中执行。 说说协程为了处理高并发、多连接下的数据读写，以往有两种解决方案。 多进程：存在频繁调度切换的问题，同时HIA存在每个进程资源不共享的问题，需要额外引入进程间通信机制来解决。 多线程：高并发场景的大量IO等待会导致多线程被频繁挂起和切换，非常消耗系统资源，同时多线程访问共享资源存在竞争问题 协程是一种比线程更加轻量级的微线程，一个线程可以拥有多个协程协程运行在线程之上，当一个协程执行完成之后，可以选择主动出让，让另一个协程运行在当前线程之上。 协程并没有增加线程 数量，只是在线程的基础之上通过分时复用的方式运行多个协程，而且协程的切换在用户态完成，切换的代价比线程从用户态到内核态的代价小很多。 因此，使用协程替换线程适用于有大量IO操作业务的情况下。一是降低了系统内存，二是减少了系统切换开销，因此系统的性能也会提升。由于在协程中调用阻塞IO的方法会导致在该线程之上的所有协程都陷入阻塞。因此协程只有和异步IO结合起来才能发挥出最大的威力 进程通信进程的用户地址空间是相互独立的，不可以互相访问，但内核空间是进程都共享的，所以进程之间要通信必须通过内核。进程间通信主要有管道、消息队列、共享内存、信号量、信号、Socket编程 管道分为匿名管道和有名管道，管道是半双工通信的。管道的本质就是内核在内存中开辟了一个缓冲区，这个缓冲区与管道文件相关联，对管道文件的操作，被内核转换成对这块缓冲区的操作。 匿名管道只能用于父子进程间的通信，有名管道只要可以访问路径就可以通过有名信号是进程通信机制中唯一的异步通信机制，它可以在任何时候发送信号给某个进程。通过发送指定信号来通知进程某个异步事件的发送，以迫使进程执行信号处理程序。信号处理完毕后，被中断进程将恢复执行。用户、内核和进程都能生成和发送信号。信号的来源有硬件来源和软件来源，常见的有Ctrl+9 1111 Socket用于跨网络与不同主机上的进程进行通信，当然也可以完成同主机上的进程通信Socket的本质是一个编程接口（API）是应用层与TCP/IP协议的网络通信的抽象层。它对TCP/IP进行了封装，它把复杂的TCP/IP协议簇隐藏在Socket接口后面。对于用户来说，只需要进行一组简单的API就可以实现网络的连接C产生SIGINT信号，表示终止该进程；软件来源如kill -管道进行通信 管道这种进程通信方式虽然使用简单，但是效率比较低，不适合进程间频繁地交换数据，并且管道只能传输无格式的字节流 消息队列的本质就是存放在内存中的消息的链表，而消息本质上是用户自定义的数据结构。如果进程从消息队列中读取了某个消息，这个消息就会从消息队列中删除 消息队列可以实现消息的随机查询，不一定要以先进先出的次序读取消息，也可以按消息类型读取，比有名管道的先进先出更有优势 用户进程写入数据到消息队列时，会发生从用户态拷贝数据到内核态，用户进程读也会发生拷贝。如果数据量较大，，使用消息队列会造成频繁系统调用，会降低性能 共享内存可以避免消息队列的拷贝消息、进行系统调用，允许不相干的进程将同一段物理内存连接到它们各自的地址空间中，使得这些进程可以访问同一个物理内存，这个物理内存就成为共享内存。如果某个进程向共享内存写入数据，所做的改动将立即影响到可以访问同一段共享内存的任何其他进程。 共享内存仅在建立共享内存区域时需要系统调用，一旦建立共享内存，所有的访问都可作为常规内存访问，无需借助内核。这样，数据就不需要在进程之间来回拷贝，所以这是最快的一种进程通信方式。但是却容易造成数据冲突 信号量，信号量是 一个整型计数器，主要用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据，保证共享内存在任何时刻只有一个进程在访问（保证互斥），并使得进程们能够按照某个特定的程序访问共享内存（同步） 利用PV操作实现 P操作：将信号量值减一，表示申请占用一个资源。如果结果小于 0，表示已经没有可用资源，则执行 P 操作的进程被阻塞。如果结果大于等于 0，表示现有的资源足够你使用，则执行 P 操作的进程继续执行。 V操作：将信号量值加一，表示释放一个资源，即使用完资源后归还资源。 信号 信号与信号量完全不同！！！ 信号是进程通信机制中唯一的异步通信机制，它可以在任何时候发送信号给某个进程。通过发送指定信号来通知进程某个异步事件的发送，以迫使进程执行信号处理程序。信号处理完毕后，被中断进程将恢复执行。用户、内核和进程都能生成和发送信号。信号的来源有硬件来源和软件来源，常见的有Ctrl+C产生SIGINT信号，表示终止该进程；软件来源如kill -9 1111 Socket用于跨网络与不同主机上的进程进行通信，当然也可以完成同主机上的进程通信Socket的本质是一个编程接口（API）是应用层与TCP/IP协议的网络通信的抽象层。它对TCP/IP进行了封装，它把复杂的TCP/IP协议簇隐藏在Socket接口后面。对于用户来说，只需要进行一组简单的API就可以实现网络的连接 信号量的值 大于 0 表示有共享资源可供使用，这个时候为什么不需要唤醒进程？所谓唤醒进程是从就绪队列（阻塞队列）中唤醒进程，而信号量的值大于 0 表示有共享资源可供使用，也就是说这个时候没有进程被阻塞在这个资源上，所以不需要唤醒，正常运行即可。 信号量的值 等于 0 的时候表示没有共享资源可供使用，为什么还要唤醒进程？V 操作是先执行信号量值加 1 的，也就是说，把信号量的值加 1 后才变成了 0，在此之前，信号量的值是 -1，即有一个进程正在等待这个共享资源，我们需要唤醒它。 使用信号量和 PV 操作实现进程的同步也非常方便，三步走： 定义一个同步信号量，并初始化为当前可用资源的数量 在优先级较高的操作的后面执行 V 操作，释放资源 在优先级较低的操作的前面执行 P 操作，申请占用资源 虚拟内存的布局 虚拟内存是如何实现的虚拟内存技术的实现是建立在离散分配的内存管理的基础上的 目前最常用的三种实现虚拟内存技术的方法： 请求分页存储管理 请求分段存储管理 请求段页式存储管理以上三种方式，无论哪种，都需要以下三个条件： 一定容量的内存和外存程序执行时，只需要将程序的一部分装入内存，就可以运行了 缺页中断若需要执行的程序未在内存中（即“缺页/段”），则处理器会通知操作系统将相应的页/段调入到内存中，与此同时也会将不常用的页/段调出到外外存中 虚拟地址空间逻辑地址转化为物理地址 用什么命令查看内存使用情况 top这个命令会动态显示系统中各个进程的资源占用状况，包括CPU使用率和内存使用情况。按Shift + M可以按照内存使用量进行排序。 ps aux该命令可以显示所有进程的详细信息，包括进程ID（PID）、用户、CPU和内存使用百分比等 top pidstat ps pmap select poll epollIO多路复用是用一个进程来维护多个Socket而select poll epoll就是内核提供给用户态的多路复用系统调用，进程可以通过一个系统调用函数从内核获取多个事件这三者都是在获取事件时，先把所有连接（文件描述符fd）传给内核，再由内核返回产生了事件的连接，然后在用户态中再处理这些连接对应的请求即可 select将已连接的 Socket 都放到一个文件描述符集合，然后调用 select 函数将文件描述符集合拷贝到内核里，让内核来检查是否有网络事件产生。检查的方式就是暴力的遍历当经检查到有事件产生后，将次Socket标记为可读或者可写， 接着再把整个文件描述符集合拷贝回用户态里，然后用户态还需要再通过遍历的方法找到可读或可写的 Socket，然后再对其处理。所以，对于select这种方式，需要进行2次遍历文件描述符集合，一次在内核态、一次在用户态。还要发生2次拷贝文件描述符集合，先从用户空间传入内核空间中，再由内核修改后，再传出到用户空间中select 使用固定长度的 BitsMap，表示文件描述符集合，而且所支持的文件描述符的个数是有限制的，在 Linux 系统中，由内核中的 FD_SETSIZE 限制， 默认最大值为 1024，只能监听 0~1023 的文件描述符。 pollpoll 不再用 BitsMap 来存储所关注的文件描述符，取而代之用动态数组，以链表形式来组织，突破了 select 的文件描述符个数限制，当然还会受到系统文件描述符限制。但是 poll 和 select 并没有太大的本质区别，都是使用「线性结构」存储进程关注的 Socket 集合，因此都需要遍历文件描述符集合来找到可读或可写的 Socket，时间复杂度为 O(n)，而且也需要在用户态与内核态之间拷贝文件描述符集合，这种方式随着并发数上来，性能的损耗会呈指数级增长。 epoll epoll 在内核里使用红黑树来跟踪进程所有待检测的文件描述字，红黑树的增删改一般时间复杂度是O（logn），由于有了红黑树来保存所有待检测的Socket，所有epoll机制不必要每次操作都传入整个Socket集合给内核，只需要传入一个待检测的Socket，减少了内核和用户空间大量数据拷贝和内存分配 epoll使用事件驱动的机制，其内核维护了一个链表来记录就绪事件，当某个Socket有事件发生时，通过回调函数，内核会将这个就绪事件加入到就绪时间列表当中，当用户调用epoll_wait函数时，只会返回有事件发生的文件描述符的个数，不需要轮询整个Socket集合，大大提高可检测效率","link":"/2024/04/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98-%E6%97%A0%E5%BA%8F%E7%89%88/"},{"title":"计算机网络之输入网址按下回车后发生了什么","text":"TCP/IP四层模型应用层传输层网络层网络接口层 物理层：连接不同的物理设备，传输比特流。在物理设备上传输数据。为上层协议提供了一个传输数据的可靠的物理媒介 中继器（Repeater 也叫放大器） 集线器 同一局域网的再生、放大信号（多端口的中继器） 半双工，不能隔离冲突域也不能隔离广播域单工通信信道 只能一个方向通信，没有反方向反馈的信道半双工通信信道 双方都可以发送接收信息，但是不能同时发送，不能同时接收全双工通信信道：双方都可以同时发送和接收 数据链路层向上层网络层提供服务，最基本的服务是将来自网络层的数据可靠地传输到相邻结点的目标机网络层。数据链路层在不可靠的物理介质上提供可靠的传输 数据链路主要作用：物理地址寻址、数据的成帧、流量控制、数据检错、重发 帧是数据链路层数据的基本单位 帧首部和尾部是特定的控制字符 透明传输：“透明”是指即使控制字符在帧数据中，但是要当做不存在去处理。即在控制字符前加上转义字符ESC 最大传输单元MTU路径MTU：即链路中MTU的最小值 以太网协议MAC地址：每个设备都有唯一的MAC地址，共48位，使用十六进制表示以太网协议完成相邻设备的数据帧传输，解决子网内部点对点的通信以太网协议只能解决单个局域网内点对点通信，多个局域网互通需要IP协议来解决 网络层实现两个端系统之间的数据透明传输，具体包括寻址、路由选择、连接的建立、保持、终止。数据交换技术是报文交换：采用储存转发方式，数据交换单位是报文网络层主要协议：IP协议（Internet Protocol，因特网互联协议）;ICMP协议（Internet Control Message Protocol，因特网控制报文协议）;ARP协议（Address Resolution Protocol，地址解析协议）;RARP协议（Reverse Address Resolution Protocol，逆地址解析协议）。IP协议提供不可靠、无连接的端到端的数据包传输服务，主要实现：数据传输 数据分片IP协议主要功能：无连接数据报传输、数据包路由选择和差错控制ICMP协议详解网际控制报文协议（Internet Control Message Protocol），可以报告错误信息或者异常情况，ICMP报文封装在IP数据报当中ICMP协议的应用： Ping应用：网络故障的排查； Traceroute应用：可以探测IP数据报在网络中走过的路径。地址解析协议 ARP（Address Resolution Protocol）：为网卡（网络适配器）的IP地址到对应的硬件地址提供动态映射。可以把网络层32位地址转化为数据链路层MAC48位地址。ARP是一个独立的三层协议，所以ARP报文在向数据链路层传输时不需要经过IP协议的封装，而是直接生成自己的报文，然后再到数据链路层封装成帧 RARP(Reverse Address Resolution Protocol)协议指逆地址解析协议，可以把数据链路层MAC48位地址转化为网络层32位地址。 网络地址转换NAT技术用于多个主机通过一个公有IP访问访问互联网的私有网络中，减缓了IP地址的消耗，但是增加了网络通信的复杂度。 NAT 工作原理： 从内网出去的IP数据报，将其IP地址替换为NAT服务器拥有的合法的公共IP地址，并将替换关系记录到NAT转换表中；从公共互联网返回的IP数据报，依据其目的的IP地址检索NAT转换表，并利用检索到的内部私有IP地址替换目的IP地址，然后将IP数据报转发到内部网络。 ARP协议与RARP协议地址解析协议ARP（Address Resolution Protocol）：为网卡（网络适配器）的IP地址到对应的硬件地址提供动态映射。把网络层32位地址转化为数据链路层MAC48位地址ARP是即插即用的，一个ARp表是自动建立的，不需要系统管理员来配置 RARP(Reverse Address Resolution Protocol)协议指逆地址解析协议，可以把数据链路层MAC48位地址转化为网络层32位地址。 输入网址后回车，之后发生了什么？ URL 解析，解析 http 协议、端口、资源地址。 DNS 查询：首先查看本地DNS缓存，再查询本地 host文件，再访问 DNS 服务器将 域名解析成 ip 地址等等。在每一步如果查到了都会直接访问 建立 TCP 连接。 服务器收到请求后处理，并且构造响应返回给客户端。 客户端接收 HTTP 报文响应。 渲染页面，最后有可能会四次挥手断开连接，也可能不会而是复用连接。URL（同一资源定位符）scheme://host.domain:port/path/filename scheme 定义应用层协议类型，比如 http、https、 ftp 等； host 定义域主机（http 的默认主机是 www）； domain 定义因特网域名，比如 segmentfault.com； port 主机的端口，http 默认是 80, https 默认是 443； path 服务器上的资源路径； filename - 定义文档/资源的名称；DNS解析过程： 本地电脑检查浏览器缓存中有没有该域名对应的解析过的IP地址。域名被缓存的时间由TTL来设置，通常要求时间长度适中，太长IP地址可能会发生变化而导致无法解析到变化后的IP地址，太短会导致用户每次访问网站都要重新解析域名 浏览器会查找操作系统缓存中是否有这个域名对应的DNS解析结果。 需要用到网络配置中的“DNS服务器地址”。操作系统会把这个域名发送给这个本地DNS服务器。 每个完整的内网通常都会配置本地DNS服务器，例如用户是在学校或工作单位接入互联网，那么用户的本地DNS服务器肯定在学校或工作单位里面。它们一般都会缓存域名解析结果，当然缓存时间是受到域名的失效时间控制的。后续的DNS迭代和递归也是由本地DNS服务器负责。 如果本地DNS服务器仍然没有命中，就直接到根DNS服务器请求解析 根DNS服务器返回给本地DNS域名服务器一个顶级DNS服务器地址，它是国际顶级域名服务器，如.com .cn等 本地DNS服务器再向上一步获得的顶级DNS服务器发送解析请求。 接受请求的顶级DNS服务器查找并且返回此域名对应的Name Server域名服务器的地址。 这个Name Server服务器就是要访问的网站域名提供商的服务器，其实该域名的解析任务就是由域名提供商的服务器来完成。 Name Server服务器会查询储存的域名和IP的映射关系表，再把查询出来的域名和IP地址等信息，连同一个TTL值返回给本地DNS服务器 本地DNS服务器返回给浏览器对应的IP和TTL值，本地DNS服务器会缓存在这个域名和IP的对应关系，缓存时间由TTL的值控制。 把解析的结果返回给本地电脑，本地电脑根据TTL值缓存在本地系统缓存中，域名解析过程结束在实际的DNS解析过程中，可能还不止这10步，如Name Server可能有很多级，或者有一个GTM来负载均衡控制，这都有可能会影响域名解析过程。 递归查询和迭代查询的区别：递归查询直接返回一个准确的查询结果，迭代查询会返回一个其他能够解析查询请求的DNS服务器，直到查询到结果。 建立TCP/IP链接 应用层：发送HTTP请求浏览器从地址栏得到服务器IP地址，接着构造一个HTTP报文，其中包括： 请求行包含请求方法、URL、协议版本 请求报头由键值对组成，每行一对，关键字与值使用英文“:”分割 请求体：请求参数，并不是所有的请求都有请求参数。也可以将参数放在body里面 传输层：TCP传输报文建立TCP/IP连接，在传输层解决了数据的可靠传输、流量控制、拥塞控制 TCP的可靠传输服务是通过确认和超时重传的机制来实现的，而确认和超时重传的具体实现是通过以字节为单位的滑动窗口机制来完成 TPC拥塞控制：TCP通过慢启动、拥塞避免、加速递减、快重传和快恢复等机制来共同实现拥塞控制 流量控制：采用通知窗口实现对发送端的流量控制，通知窗口大小的单位是字节。TCP通过在TCP数据段首部的窗口字段中填入当前设定的接收窗口（即通知窗口）的大小，用来告知对方’我放当前的接收窗口的大小’，以实现流量控制。发送窗口大小在建立连接时商定，在通信过程，双方可以动态地根据自己的情况调整对方的发送窗口大小 网络层：IP协议查询与MAC地址将数据段打包，并加入源和目标的IP地址，并且负责寻找传输路线。判断目标地址是否与当前地址处于同一网络中，是的话直接根据MAC地址发送，否则使用路由表查找下一跳地址，以及使用ARP（地址解析协议）查询它的MAC地址 链路层：以太网协议根据以太网协议将数据分为以“帧”为单位的数据包，每一帧分为两个部分： 标头：数据包的发送者、接受者、数据类型 数据：数据包具体内容 MAC地址以太网规定了连入网络的所有设备都必须具备“网卡”接口，数据包都是从一块网卡传递到另一块网卡，网卡的地址就是 Mac 地址。每一个 Mac 地址都是独一无二的，具备了一对一的能力 三次握手与四次挥手硬不硬你说了算！全图解被问千百遍的TCP三次握手和四次挥手面试题 (qq.com)","link":"/2024/04/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8B%E8%BE%93%E5%85%A5%E7%BD%91%E5%9D%80%E6%8C%89%E4%B8%8B%E5%9B%9E%E8%BD%A6%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/"},{"title":"用JavaSocket编程开发聊天室","text":"用JavaSocket编程开发聊天室实验要求： 用Java图形用户界面编写聊天室服务器端和客户端， 支持多个客户端连接到一个服务器。每个客户端能够输入账号。 可以实现群聊（聊天记录显示在所有客户端界面）。 完成好友列表在各个客户端上显示。 可以实现私人聊天，用户可以选择某个其他用户，单独发送信息。 服务器能够群发系统消息，能够强行让某些用户下线。 客户端的上线下线要求能够在其他客户端上面实时刷新。本人目前大二，这是期末课程设计做得一个完整的玩具项目，但是由于水平和时间等问题，这个项目的设计和架构还是有些问题，比如说发送消息和指令都是使用Socket发送的，仅仅使用一些特殊字符来区别消息和指令，如果用户端直接发送和指令相同的字符串，则会导致bug。因此本项目的健壮性和可拓展性都较差，仅能作为课设使用。分为客户端和服务器端。 服务器端功能： 可以实现查看所有在线用户 可以强制下线在线用户 可以发送系统消息 用户正常登录和退出会通知所有在线用户 客户端功能： 输入服务器、端口和用户名即可登录 可以发生群聊消息 右侧显示所有在线用户 双击右侧在线用户可发送私信 项目地址：javaSocket聊天室 客户端Client： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117package client;import java.io.*;import java.net.Socket;import java.net.UnknownHostException;public class Client { private Socket socket; private DataOutputStream outputStream; private PrintWriter out; private BufferedReader in; private String serverAddress; private int port; private String username; private OnMessageReceivedListener listener; public Client(String serverAddress, int port, String username, OnMessageReceivedListener listener) throws IOException { this.serverAddress = serverAddress; this.port = port; this.username = username; this.listener = listener; initConnection(); } private void initConnection() throws IOException { if (socket != null &amp;&amp; !socket.isClosed()) { return; } socket = new Socket(serverAddress, port); outputStream = new DataOutputStream(socket.getOutputStream()); out = new PrintWriter(new OutputStreamWriter(socket.getOutputStream(), &quot;UTF-8&quot;), true); in = new BufferedReader(new InputStreamReader(socket.getInputStream(), &quot;UTF-8&quot;)); } public void sendMessage(String message) { if (outputStream != null &amp;&amp; !socket.isClosed()) { try { out.println(message); out.flush(); } catch (Exception e) { handleSendError(e); } } else { System.err.println(&quot;Socket is not properly initialized or is closed.&quot;); } } public void sendPrivateMessage(String recipient, String message) { sendMessage(&quot;/pm &quot; + recipient + &quot; &quot; + message); } private void handleSendError(Exception e) { e.printStackTrace(); try { socket.close(); } catch (IOException closeException) { closeException.printStackTrace(); } listener.onConnectionLost(); } public void connect() { try { initConnection(); sendMessage(username); // 发送用户名以登录 Thread readerThread = new Thread(() -&gt; { String message; try { while ((message = in.readLine()) != null) { listener.onMessageReceived(message); } } catch (IOException e) { listener.onConnectionLost(); e.printStackTrace(); } finally { try { socket.close(); } catch (IOException ex) { ex.printStackTrace(); } } }); readerThread.start(); } catch (UnknownHostException e) { System.err.println(&quot;Server not found: &quot; + e.getMessage()); listener.onConnectionLost(); } catch (IOException e) { System.err.println(&quot;Error connecting to server: &quot; + e.getMessage()); listener.onConnectionLost(); } } public void disconnect() { try { if (socket != null) { socket.close(); } } catch (IOException e) { e.printStackTrace(); } } public String getUsername() { return username; } public interface OnMessageReceivedListener { void onMessageReceived(String message); void onConnectionLost(); void onUpdateOnlineUsers(String userListData); void onForceLogout(); }} 客户端界面ClientGUI： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168package client;import javax.swing.*;import java.awt.*;import java.awt.event.MouseAdapter;import java.awt.event.MouseEvent;public class ClientGUI extends Component { private JTextField serverAddressField, portField, usernameField, messageField; private JButton connectButton, sendButton; private JTextArea chatArea; private JList&lt;String&gt; onlineList; private DefaultListModel&lt;String&gt; onlineListModel; private Client client; public static void main(String[] args) { SwingUtilities.invokeLater(() -&gt; new ClientGUI().initializeUI()); } private void initializeUI() { JFrame frame = new JFrame(&quot;Chat Client&quot;); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); frame.setSize(800, 600); chatArea = new JTextArea(); chatArea.setEditable(false); JScrollPane scrollPane = new JScrollPane(chatArea); frame.add(scrollPane, BorderLayout.CENTER); JPanel southPanel = new JPanel(); southPanel.setLayout(new BorderLayout()); JPanel inputPanel = new JPanel(); inputPanel.setLayout(new FlowLayout(FlowLayout.LEFT)); messageField = new JTextField(30); sendButton = new JButton(&quot;Send&quot;); inputPanel.add(messageField); inputPanel.add(sendButton); southPanel.add(inputPanel, BorderLayout.CENTER); JPanel connectPanel = new JPanel(); connectPanel.setLayout(new FlowLayout(FlowLayout.LEFT)); serverAddressField = new JTextField(&quot;localhost&quot;, 10); portField = new JTextField(&quot;12345&quot;, 5); usernameField = new JTextField(&quot;User&quot;, 10); connectButton = new JButton(&quot;Connect&quot;); connectPanel.add(new JLabel(&quot;Server: &quot;)); connectPanel.add(serverAddressField); connectPanel.add(new JLabel(&quot; Port: &quot;)); connectPanel.add(portField); connectPanel.add(new JLabel(&quot; Username: &quot;)); connectPanel.add(usernameField); connectPanel.add(connectButton); southPanel.add(connectPanel, BorderLayout.SOUTH); frame.add(southPanel, BorderLayout.SOUTH); onlineListModel = new DefaultListModel&lt;&gt;(); onlineList = new JList&lt;&gt;(onlineListModel); JScrollPane onlineScrollPane = new JScrollPane(onlineList); onlineScrollPane.setPreferredSize(new Dimension(150, 0)); frame.add(onlineScrollPane, BorderLayout.EAST); createEvents(); frame.setVisible(true); } private void createEvents() { connectButton.addActionListener(e -&gt; { String serverAddress = serverAddressField.getText(); int port = Integer.parseInt(portField.getText()); String username = usernameField.getText(); connectButton.setEnabled(false); try { client = new Client(serverAddress, port, username, new GUIListener()); client.connect(); } catch (Exception ex) { JOptionPane.showMessageDialog(this, &quot;连接失败，请检查输入信息。&quot;, &quot;连接错误&quot;, JOptionPane.ERROR_MESSAGE); connectButton.setEnabled(true); } }); sendButton.addActionListener(e -&gt; { String message = messageField.getText(); if (!message.isEmpty()) { client.sendMessage(message); displaySentMessage(message); messageField.setText(&quot;&quot;); } }); onlineList.addMouseListener(new MouseAdapter() { @Override public void mouseClicked(MouseEvent e) { if (e.getClickCount() == 2) { String selectedUser = onlineList.getSelectedValue(); if (selectedUser != null &amp;&amp; client != null) { String privateMessage = JOptionPane.showInputDialog(ClientGUI.this, &quot;输入要发送给 &quot; + selectedUser + &quot; 的消息:&quot;, &quot;发送私信&quot;, JOptionPane.PLAIN_MESSAGE); if (privateMessage != null &amp;&amp; !privateMessage.trim().isEmpty()) { client.sendPrivateMessage(selectedUser, privateMessage); displaySentMessage(&quot;[私信给 &quot; + selectedUser + &quot;]: &quot; + privateMessage); // 显示发送的私聊消息 } } } } }); } private void displaySentMessage(String message) { SwingUtilities.invokeLater(() -&gt; { chatArea.append(client.getUsername() + &quot;: &quot; + message + &quot;\\n&quot;); chatArea.setCaretPosition(chatArea.getDocument().getLength()); }); } private class GUIListener implements Client.OnMessageReceivedListener { @Override public void onMessageReceived(String message) { SwingUtilities.invokeLater(() -&gt; { if (message.startsWith(&quot;/users &quot;)) { // 检查消息是否以/users开头 onUpdateOnlineUsers(message.substring(7)); // 去掉&quot;/users &quot;前缀，然后更新在线用户列表 }else if(message.equals(&quot;/forceLogout&quot;)){ onForceLogout(); }else if(message.equals(&quot;/server/ERROR: 用户名已被占用，请选择其他用户名。&quot;)){ JOptionPane.showMessageDialog(ClientGUI.this, &quot;用户名已被占用，请选择其他用户名。&quot;, &quot;连接错误&quot;, JOptionPane.ERROR_MESSAGE); connectButton.setEnabled(true); client.disconnect(); }else if(message.equals(&quot;/server/SUCCESS: 连接成功&quot;)){ JOptionPane.showMessageDialog(ClientGUI.this, &quot;连接成功&quot;, &quot;连接状态&quot;, JOptionPane.INFORMATION_MESSAGE); } else { chatArea.append(message + &quot;\\n&quot;); chatArea.setCaretPosition(chatArea.getDocument().getLength()); } }); } @Override public void onConnectionLost() { SwingUtilities.invokeLater(() -&gt; { JOptionPane.showMessageDialog(ClientGUI.this, &quot;连接丢失，请检查网络或重新登录。&quot;, &quot;连接错误&quot;, JOptionPane.ERROR_MESSAGE); connectButton.setEnabled(true); }); } @Override public void onUpdateOnlineUsers(String userListData) { SwingUtilities.invokeLater(() -&gt; { String[] usernames = userListData.split(&quot;,&quot;); // 假设用户列表是以逗号分隔的用户名 onlineListModel.clear(); // 清空现有在线用户列表 for (String username : usernames) { onlineListModel.addElement(username.trim()); // 添加每个用户名到在线用户列表模型中 } }); } @Override public void onForceLogout(){ SwingUtilities.invokeLater(() -&gt; { JOptionPane.showMessageDialog(null, &quot;抱歉！您已被服务器强制下线！&quot;, &quot;强制下线&quot;, JOptionPane.WARNING_MESSAGE); System.exit(0); // 关闭客户端程序 }); } }} Common包下Message类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package common;import java.time.LocalDateTime;import java.time.format.DateTimeFormatter;public class Message { private String sender; private String recipient; private String content; private LocalDateTime timestamp; // 构造函数 public Message(String sender, String recipient, String content) { this.sender = sender; this.recipient = recipient; this.content = content; this.timestamp = LocalDateTime.now(); // 当前时间作为发送时间 } public Message(String sender, String content) { this(sender, &quot;Everyone&quot;, content); } // Getter 和 Setter 方法 public String getSender() { return sender; } public void setSender(String sender) { this.sender = sender; } public String getRecipient() { return recipient; } public void setRecipient(String recipient) { this.recipient = recipient; } public String getContent() { return content; } public void setContent(String content) { this.content = content; } public LocalDateTime getTimestamp() { return timestamp; } // 格式化时间戳的字符串表示 public String getFormattedTimestamp() { DateTimeFormatter formatter = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;); return timestamp.format(formatter); } // 重写toString方法，便于打印或显示消息详情 @Override public String toString() { return String.format(&quot;[%s] %s -&gt; %s: %s&quot;, getFormattedTimestamp(), sender, recipient, content); }} 服务器端Server： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108package server;import java.io.*;import java.net.ServerSocket;import java.net.Socket;import java.util.ArrayList;import java.util.List;import common.Message;public class Server { private static final int PORT = 12345; // 服务器端口 private final List&lt;ServerThread&gt; clients = new ArrayList&lt;&gt;(); // 存储所有连接的客户端线程 private ServerGUI gui; public Server(ServerGUI gui) { this.gui = gui; } public static void main(String[] args) { ServerGUI gui = new ServerGUI(); Server server = new Server(gui); gui.setServer(server); server.startServer(); } public void startServer() { try (ServerSocket serverSocket = new ServerSocket(PORT)) { System.out.println(&quot;服务器启动，正在监听端口: &quot; + PORT); while (true) { Socket socket = serverSocket.accept(); // 阻塞等待客户端连接 ServerThread serverThread = new ServerThread(socket, this); serverThread.start(); // 启动线程处理客户端请求 System.out.println(&quot;新客户端连接: &quot; + socket.getInetAddress()); } } catch (IOException e) { e.printStackTrace(); System.err.println(&quot;服务器启动失败&quot;); } } public synchronized void addClient(ServerThread client) { clients.add(client); updateOnlineUsers(); gui.updateUserList(clients); } public synchronized boolean removeClient(ServerThread client) { boolean removed = clients.remove(client); if (removed) { updateOnlineUsers(); gui.updateUserList(clients); } return removed; } public synchronized void broadcast(Message message, ServerThread excludeClient) { for (ServerThread client : clients) { if (client != excludeClient) { client.send(message); } } } public synchronized void updateOnlineUsers() { StringBuilder userList = new StringBuilder(&quot;/users &quot;); for (ServerThread client : clients) { userList.append(client.getUsername()).append(&quot;,&quot;); } String userListMessage = userList.toString(); if (userListMessage.endsWith(&quot;,&quot;)) { userListMessage = userListMessage.substring(0, userListMessage.length() - 1); } for (ServerThread client : clients) { client.sendRawMessage(userListMessage); } } public List&lt;ServerThread&gt; getClients() { return clients; } public void forceLogout(String username) { for (ServerThread client : clients) { if (client.getUsername().equals(username)) { client.interrupt(); // 中断客户端线程以强制下线 removeClient(client); // 从列表中移除客户端 client.forceLogout(); gui.updateUserList(clients); break; } } } public synchronized boolean isUsernameTaken(String username) { for (ServerThread client : clients) { if (client.getUsername().equals(username)) { return true; } } return false; } public synchronized void sendSystemMessage(String content) { Message systemMessage = new Message(&quot;Server&quot;, &quot;Everyone&quot;, content); broadcast(systemMessage, null); }} 客户端界面ServerGUI： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879package server;import javax.swing.*;import java.awt.*;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import java.util.List;public class ServerGUI extends JFrame { private JList&lt;String&gt; userList; private DefaultListModel&lt;String&gt; userListModel; private Server server; public ServerGUI() { setTitle(&quot;Chat Server&quot;); setSize(400, 300); setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); setLocationRelativeTo(null); userListModel = new DefaultListModel&lt;&gt;(); userList = new JList&lt;&gt;(userListModel); JScrollPane scrollPane = new JScrollPane(userList); JButton forceLogoutButton = new JButton(&quot;Force Logout&quot;); forceLogoutButton.addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent e) { String selectedUser = userList.getSelectedValue(); if (selectedUser != null) { server.forceLogout(selectedUser); } } }); // 系统消息输入框和发送按钮 JTextField systemMessageField = new JTextField(); JButton sendSystemMessageButton = new JButton(&quot;发送系统消息&quot;); sendSystemMessageButton.addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent e) { String message = systemMessageField.getText(); if (message != null &amp;&amp; !message.trim().isEmpty()) { server.sendSystemMessage(message); systemMessageField.setText(&quot;&quot;); // 清空输入框 } } }); JPanel panel = new JPanel(new BorderLayout()); panel.add(scrollPane, BorderLayout.CENTER); panel.add(forceLogoutButton, BorderLayout.SOUTH); // 系统消息面板 JPanel systemMessagePanel = new JPanel(new BorderLayout()); systemMessagePanel.add(systemMessageField, BorderLayout.CENTER); systemMessagePanel.add(sendSystemMessageButton, BorderLayout.EAST); // 添加到主窗口 add(panel, BorderLayout.CENTER); add(systemMessagePanel, BorderLayout.SOUTH); setVisible(true); } public void updateUserList(List&lt;ServerThread&gt; clients) { SwingUtilities.invokeLater(() -&gt; { userListModel.clear(); for (ServerThread client : clients) { userListModel.addElement(client.getUsername()); } }); } public void setServer(Server server) { this.server = server; }} 客户端ServerThread： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116package server;import common.Message;import java.io.*;import java.net.Socket;public class ServerThread extends Thread { private Socket socket; private PrintWriter out; private BufferedReader in; private String username; private Server server; private volatile boolean running = true; public ServerThread(Socket socket, Server server) { this.socket = socket; this.server = server; try { out = new PrintWriter(socket.getOutputStream(), true); in = new BufferedReader(new InputStreamReader(socket.getInputStream())); } catch (IOException e) { e.printStackTrace(); System.err.println(&quot;Error initializing streams for client: &quot; + e.getMessage()); } } @Override public void run() { try { this.username = in.readLine(); if (server.isUsernameTaken(this.username)) { sendRawMessage(&quot;/server/ERROR: 用户名已被占用，请选择其他用户名。&quot;); socket.close(); return; } sendRawMessage(&quot;/server/SUCCESS: 连接成功&quot;); System.out.println(&quot;账号&quot; + this.username + &quot;已经登录&quot;); server.addClient(this); // 注意不要在构造函数中重复调用 addClient server.broadcast(new Message(username, &quot;Server&quot;, username + &quot; has joined the chat!&quot;), this); String inputLine; while (running &amp;&amp; (inputLine = in.readLine()) != null) { if (inputLine.startsWith(&quot;/pm &quot;)) { handlePrivateMessage(inputLine); } else { server.broadcast(new Message(username, &quot;Everyone&quot;, inputLine), this); } } } catch (IOException e) { e.printStackTrace(); } finally { boolean removed = server.removeClient(this); if (removed) { server.broadcast(new Message(username, &quot;Server&quot;, username + &quot; has left the chat!&quot;), null); } try { socket.close(); } catch (IOException e) { e.printStackTrace(); } } } public void send(Message message) { if (out != null &amp;&amp; !out.checkError()) { out.println(message.toString()); out.flush(); } } public void sendRawMessage(String message) { try { if (out != null &amp;&amp; !out.checkError()) { out.println(message); out.flush(); } else { System.err.println(&quot;Output stream is closed, cannot send message.&quot;); } } catch (Exception e) { e.printStackTrace(); System.err.println(&quot;Error sending message: &quot; + e.getMessage()); } } private void handlePrivateMessage(String inputLine) { int firstSpace = inputLine.indexOf(&quot; &quot;); int secondSpace = inputLine.indexOf(&quot; &quot;, firstSpace + 1); if (secondSpace != -1) { String recipient = inputLine.substring(firstSpace + 1, secondSpace); String message = inputLine.substring(secondSpace + 1); for (ServerThread client : server.getClients()) { if (client.getUsername().equals(recipient)) { client.send(new Message(username, recipient, message)); break; } } } } public String getUsername() { return username; } public void forceLogout() { running = false; // 停止主循环 sendRawMessage(&quot;/forceLogout&quot;); try { socket.close(); // 关闭Socket以触发IOException并停止线程 } catch (IOException e) { e.printStackTrace(); } }} 使用方法首先启动服务器端Server，再启动客户端界面ClientGUI，关于同时启动多个实例比较简单，大家可以自行搜索。 其他个人主页：张明宇的个人主页","link":"/2024/06/05/%E7%94%A8JavaSocket%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91%E8%81%8A%E5%A4%A9%E5%AE%A4/"}],"tags":[{"name":"操作系统","slug":"操作系统","link":"/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"Raft","slug":"Raft","link":"/tags/Raft/"},{"name":"JAVA","slug":"JAVA","link":"/tags/JAVA/"},{"name":"Redis","slug":"Redis","link":"/tags/Redis/"},{"name":"k8s","slug":"k8s","link":"/tags/k8s/"},{"name":"计算机网络","slug":"计算机网络","link":"/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"categories":[{"name":"操作系统","slug":"操作系统","link":"/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"Raft","slug":"Raft","link":"/categories/Raft/"},{"name":"JAVA","slug":"JAVA","link":"/categories/JAVA/"},{"name":"Redis","slug":"Redis","link":"/categories/Redis/"},{"name":"k8s","slug":"k8s","link":"/categories/k8s/"},{"name":"计算机网络","slug":"计算机网络","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"pages":[]}